package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"

	"github.com/couchcryptid/storm-data-api/internal/model"
	"golang.org/x/sync/errgroup"
)

// StormReports is the resolver for the stormReports field.
func (r *queryResolver) StormReports(ctx context.Context, filter model.StormReportFilter) (*model.StormReportsResult, error) {
	if err := ValidateFilter(&filter); err != nil {
		return nil, err
	}

	result := &model.StormReportsResult{
		Aggregations: &model.StormAggregations{},
		Meta:         &model.QueryMeta{},
	}

	g, gCtx := errgroup.WithContext(ctx)
	fields := collectFields(ctx)

	// Reports + count
	g.Go(func() error {
		reports, count, err := r.Store.ListStormReports(gCtx, &filter)
		if err != nil {
			return err
		}
		result.Reports = reports
		result.TotalCount = count
		result.Aggregations.TotalCount = count
		offset := 0
		if filter.Offset != nil {
			offset = *filter.Offset
		}
		result.HasMore = offset+len(reports) < count
		return nil
	})

	// Aggregations (if requested)
	if fields["aggregations"] {
		g.Go(func() error {
			agg, err := r.Store.Aggregations(gCtx, &filter)
			if err != nil {
				return err
			}
			if fields["aggregations.byEventType"] {
				result.Aggregations.ByEventType = agg.ByEventType
			}
			if fields["aggregations.byState"] {
				result.Aggregations.ByState = agg.ByState
			}
			if fields["aggregations.byHour"] {
				result.Aggregations.ByHour = agg.ByHour
			}
			return nil
		})
	}

	// Meta (if requested)
	if fields["meta"] {
		g.Go(func() error {
			return applyMeta(gCtx, r.Store, result.Meta)
		})
	}

	if err := g.Wait(); err != nil {
		return nil, err
	}
	return result, nil
}

// EventType is the resolver for the eventType field.
func (r *stormReportResolver) EventType(ctx context.Context, obj *model.StormReport) (string, error) {
	return obj.EventType, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// StormReport returns StormReportResolver implementation.
func (r *Resolver) StormReport() StormReportResolver { return &stormReportResolver{r} }

type queryResolver struct{ *Resolver }
type stormReportResolver struct{ *Resolver }
